<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>开发 on CyderX</title>
    <link>https://davyxx3.github.io/categories/%E5%BC%80%E5%8F%91/</link>
    <description>Recent content in 开发 on CyderX</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 26 Nov 2021 10:00:00 +0800</lastBuildDate><atom:link href="https://davyxx3.github.io/categories/%E5%BC%80%E5%8F%91/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>谈谈缓存穿透、击穿和雪崩</title>
      <link>https://davyxx3.github.io/p/%E8%B0%88%E8%B0%88%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%87%BB%E7%A9%BF%E5%92%8C%E9%9B%AA%E5%B4%A9/</link>
      <pubDate>Fri, 26 Nov 2021 10:00:00 +0800</pubDate>
      
      <guid>https://davyxx3.github.io/p/%E8%B0%88%E8%B0%88%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%87%BB%E7%A9%BF%E5%92%8C%E9%9B%AA%E5%B4%A9/</guid>
      <description>缓存穿透及优化 缓存穿透：查询一个根本不存在的数据，缓存层和存储层都不会命中
缓存穿透导致不存在的数据每次请求都要到存储层查询，缓存的保护失去了意义，会使后端存储负载加大
缓存穿透图示
解决办法
  缓存空对象：存储层不命中后，将空对象保存至缓存层中，之后的访问都会从缓存层获取，这样就保护了后端数据
缺点：
 缓存空对象，意味着缓存中存了更多的键，会占用空间，可以通过设置过期时间解决 缓存层和存储层会有一段时间窗口的不一致（比如缓存层中存了空对象并设置过期时间为5分钟，但此时存储层刚好添加了该键对应的数据，就造成了数据不一致），可以使用消息系统或者其他方式解决    布隆过滤器拦截：缓存穿透是查询一个根本不存在的数据，因此可以在缓存层前加一个布隆过滤器，将不存在的数据拦截。
 关于布隆过滤器，可以查看我写的另一篇文章：布隆过滤器的简单总结
   
两种解决方式的对比
   解决方式 适用场景 代价     缓存空对象 数据命中不高、数据变化频繁（实时性高） 需要过多缓存空间、数据不一致   布隆过滤器 数据命中不高，数据相对固定（实时性低） 代码维护复杂    PS：布隆过滤器不适用于数据变化频繁的场景（因为要不停地进行数据的插入和删除，而布隆过滤器对于删除操作极不友好），比较适用于数据相对固定的场景
缓存击穿及其优化 缓存层的某个key承受着非常高的并发，当这个key失效的瞬间，大量的请求会同时击穿缓存，打到DB，就像在纱窗上戳破了一个洞
缓存击穿图示
解决方法
 设置热点数据不过期，这里的不过期是指物理上的不过期。我们可以设置一个逻辑过期时间，当超过逻辑过期时间时，异步地加载数据，更新缓存。这种方法适用于比较极端的场景（流量特别大），需要承受数据不一致的代价（缓存重构需要时间） 给访问DB操作加上互斥锁，只有一个线程能拿到锁，请求DB并把数据刷到缓存中，其他线程再从缓存拿这个数据  两种解决方法的对比
   解决方法 优点 缺点     简单分布式锁 思路简单、保证一致性 代码复杂度大、存在死锁和线程池阻塞的风险   热点数据永不过期 杜绝缓存击穿问题 不保证一致性、代码维护成本和内存成本增加    缓存雪崩及优化 缓存层因为某些原因无法提供服务（比如缓存服务器重启，或者大量key在同一时间失效等情况），所有请求都打到存储层，则存储层的调用量会暴增，造成存储层也级联宕机的情况</description>
    </item>
    
    <item>
      <title>布隆过滤器的简单总结</title>
      <link>https://davyxx3.github.io/p/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/</link>
      <pubDate>Fri, 26 Nov 2021 08:00:00 +0800</pubDate>
      
      <guid>https://davyxx3.github.io/p/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/</guid>
      <description>布隆过滤器（Bloom Filter）是一个很长的二进制向量和一系列随机映射函数
用途：判断一个元素是否在一个集合中
严谨来说，应该是：判断某样东西一定不存在或可能存在
数据存入  经过K个哈希函数计算，返回K个计算出的hash值 这k个hash值映射到对应的k个数组下标 将二进制向量中这k个下标的对应数据改为1  数据存入的过程
数据查询  经过K个哈希函数计算该数据，算出k个hash值 以hash值为下标在二进制向量中找到对应的数据 若有一处的数据为0，则该数据不存在，否则说明数据可能存在（并不是一定存在，有误判的可能）  参数选择 二进制向量的长度会影响误报率，长度越长，误报率越低
 若长度太小，所有bit都置成1的话，那么查询任何值都会返回“可能存在”，无法起到过滤的目的 若长度太大，则可能会造成空间浪费  哈希函数的个数也会影响误报率，函数个数越多，误报率越低
 若函数个数太多，则二进制向量置1的速度会变得很快，这样布隆过滤器的效率会变低 若函数个数太少，则误报率变高  参数的选取公式：
m和k的计算公式
k为哈希函数个数，m为布隆过滤器长度，n为插入元素的个数，p为误报率
总结 优点：
 占用空间小（存储的是二进制数据） 查询速度快，时间复杂度为O(k) 保密性很好，不存储任何原始数据，只有二进制数据  缺点：
 存在误判的可能（不同的数据可能映射到二进制向量中的相同位置） 删除困难，也是因为上述的理由  与HashMap的比较：
HashMap速度也很快，但占用空间太大，因为有负载因子的存在，为了避免哈希冲突，空间是没办法用满的，会造成大量的空间浪费。使用布隆过滤器可以在不牺牲查找速度的同时，降低空间消耗，代价就是判断并不完全准确
应用场景：
 URL黑名单过滤 解决缓存穿透的问题 &amp;hellip;  </description>
    </item>
    
    <item>
      <title>ConcurrentLinkedQueue源码分析</title>
      <link>https://davyxx3.github.io/p/concurrentlinkedqueue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link>
      <pubDate>Fri, 26 Nov 2021 01:00:00 +0800</pubDate>
      
      <guid>https://davyxx3.github.io/p/concurrentlinkedqueue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid>
      <description>简介 ConcurrentLinkedQueue是高并发环境中性能最好的队列
要想队列保证线程安全，有两种实现方式
 阻塞算法：锁 非阻塞算法：循环CAS  在队列中，BlockingQueue是阻塞算法的典型实现（使用锁来保证线程安全），而ConcurrentLinkedQueue则是非阻塞算法的典型实现（使用CAS保证线程安全）
原理 ConcurrentLinkedQueue的基本结构
Node节点
static final class Node&amp;lt;E&amp;gt; { volatile E item; volatile Node&amp;lt;E&amp;gt; next; // 利用CAS操作向后添加一个节点  void appendRelaxed(Node&amp;lt;E&amp;gt; next) { NEXT.set(this, next); } // 利用CAS操作设置值（cmp是期望值，val是要设置的值）  boolean casItem(E cmp, E val) { return ITEM.compareAndSet(this, cmp, val); } } head和tail
transient volatile Node&amp;lt;E&amp;gt; head; private transient volatile Node&amp;lt;E&amp;gt; tail; // 初始时，head和tail都指向一个空节点 public ConcurrentLinkedQueue() { head = tail = new Node&amp;lt;E&amp;gt;(); } CoucurrentLinkedQueue规定了如下几个不变性：</description>
    </item>
    
  </channel>
</rss>
