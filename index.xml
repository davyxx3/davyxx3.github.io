<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>CyderX</title>
        <link>https://cyderx.com/</link>
        <description>Recent content on CyderX</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Mon, 06 Dec 2021 01:00:00 +0800</lastBuildDate><atom:link href="https://cyderx.com/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Redis底层数据结构</title>
        <link>https://cyderx.com/p/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
        <pubDate>Mon, 06 Dec 2021 01:00:00 +0800</pubDate>
        
        <guid>https://cyderx.com/p/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
        <description>&lt;img src="https://cyderx.com/p/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/bg.jpg" alt="Featured image of post Redis底层数据结构" /&gt;&lt;p&gt;先挖个坑，还没更完，有时间再补充完整 :)&lt;/p&gt;
&lt;h2 id=&#34;底层数据结构&#34;&gt;底层数据结构&lt;/h2&gt;
&lt;h3 id=&#34;sds&#34;&gt;SDS&lt;/h3&gt;
&lt;p&gt;简单动态字符串（Simple Dynamic String）&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://cdn.jsdelivr.net/gh/davyxx3/pics/blog_img/image-20211206180705865.png&#34; &gt;
		&lt;img src=&#34;https://cdn.jsdelivr.net/gh/davyxx3/pics/blog_img/image-20211206180705865.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;SDS的底层结构&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;SDS的底层结构&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;常数复杂度获取字符串长度&lt;/li&gt;
&lt;li&gt;防止缓冲区溢出&lt;/li&gt;
&lt;li&gt;减少修改字符串的内存重分配次数（空间预分配，小于1MB时分配和len同样大小的未使用空间，大于1MB时分配1MB的未使用空间）&lt;/li&gt;
&lt;li&gt;二进制安全（可以包含空字符）&lt;/li&gt;
&lt;li&gt;兼容部分C字符串函数&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;链表&#34;&gt;链表&lt;/h3&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://cdn.jsdelivr.net/gh/davyxx3/pics/blog_img/image-20211206181332853.png&#34; &gt;
		&lt;img src=&#34;https://cdn.jsdelivr.net/gh/davyxx3/pics/blog_img/image-20211206181332853.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;链表的底层结构&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;链表的底层结构&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;双端&lt;/li&gt;
&lt;li&gt;无环&lt;/li&gt;
&lt;li&gt;带表头指针和表尾指针&lt;/li&gt;
&lt;li&gt;带链表长度计数器&lt;/li&gt;
&lt;li&gt;多态&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;字典&#34;&gt;字典&lt;/h3&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://cdn.jsdelivr.net/gh/davyxx3/pics/blog_img/image-20211206181352391.png&#34; &gt;
		&lt;img src=&#34;https://cdn.jsdelivr.net/gh/davyxx3/pics/blog_img/image-20211206181352391.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;字典的底层结构&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;字典的底层结构&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;dict（字典） -&amp;gt; dictht（dict hash table，也就是哈希表）-&amp;gt; dictEntry（哈希表节点）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一般字典只使用ht[0]哈希表，ht[1]只会在扩容时使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;rehashidx记录rehash目前的进度，如果没有在进行rehash，则值为-1&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Redis使用MurmurHash2算法计算hash值&lt;/p&gt;
&lt;p&gt;在使用链表解决哈希冲突问题时，Redis把新加入的节点放在链表的表头位置，从而加快查找速度&lt;/p&gt;
&lt;h4 id=&#34;rehash&#34;&gt;rehash&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;为ht[1]分配空间，大小取决于ht[0]的键值对数量&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;扩容：ht[1]的大小为第一个大于等于ht[0].used * 2的2^n&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;收缩：ht[1]的大小为第一个大于等于ht[0].used的2^n&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重新计算索引值，移动元素&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;释放ht[0]，ht[1]变为ht[0]，ht[1]创建一个空表&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;采用渐进式rehash，将计算工作均摊到对字典的每个增删改查操作上&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;扩容条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;没在执行BGSAVE或BGWRITEAOF命令，且负载因子大于等于1&lt;/li&gt;
&lt;li&gt;正在执行BGSAVE或BGWRITEAOF命令，且负载因子大于等于5&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;负载因子阈值不同的原因：Redis执行这些备份命令时，创建了一个子进程，使用写时复制技术来优化效率，此时应该避免向内存中写入新的数据（写入数据会在内存中创建新的页，造成性能开销），因此将负载因子阈值调高，防止触发扩容进行大量的写操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;收缩条件：负载因子小于0.1&lt;/p&gt;
&lt;h3 id=&#34;跳表&#34;&gt;跳表&lt;/h3&gt;
&lt;p&gt;平均O(logN)，最坏O(N)&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://cdn.jsdelivr.net/gh/davyxx3/pics/blog_img/image-20211205014408359.png&#34; &gt;
		&lt;img src=&#34;https://cdn.jsdelivr.net/gh/davyxx3/pics/blog_img/image-20211205014408359.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;跳表的底层结构&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;跳表的底层结构&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;跳跃表节点的结构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;level[]（层数组），其中包含的元素：
&lt;ul&gt;
&lt;li&gt;前进指针（下一个节点的指针）&lt;/li&gt;
&lt;li&gt;跨度（下一个节点和此节点的距离）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;backward（后退指针）：用于从尾部向前遍历&lt;/li&gt;
&lt;li&gt;score（分值）：（用于排序）&lt;/li&gt;
&lt;li&gt;obj：成员对象：指向字符串对象，它保存着一个SDS&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;层&#34;&gt;层&lt;/h4&gt;
&lt;p&gt;创建新跳表节点时，根据&lt;strong&gt;幂次定律&lt;/strong&gt;（power law，越大的数出现概率越小），随机生成一个介于1-32之间的值作为level数组的大小，这个大小就是层的高度&lt;/p&gt;
&lt;h3 id=&#34;整数集合&#34;&gt;整数集合&lt;/h3&gt;
&lt;p&gt;整数集合（intset）是保存整数的集合抽象数据类型，各个项在数组中按值的大小从小到大排序&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://cdn.jsdelivr.net/gh/davyxx3/pics/blog_img/image-20211206180725694.png&#34; &gt;
		&lt;img src=&#34;https://cdn.jsdelivr.net/gh/davyxx3/pics/blog_img/image-20211206180725694.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;整数集合的底层结构&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;整数集合的底层结构&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&#34;升级&#34;&gt;升级&lt;/h4&gt;
&lt;p&gt;如果添加的元素类型比现有的元素类型长，则需要先进行升级（upgrade）&lt;/p&gt;
&lt;p&gt;步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;扩展数组空间大小&lt;/li&gt;
&lt;li&gt;将现有元素全部转换为新类型的大小，并放至在正确的位上，保证有序性质&lt;/li&gt;
&lt;li&gt;插入新元素&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因为可能需要升级，所以添加的时间复杂度是O(N)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;只要升级，就不会降级，没有降级机制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提升灵活性&lt;/li&gt;
&lt;li&gt;节约内存&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;压缩列表&#34;&gt;压缩列表&lt;/h3&gt;
&lt;p&gt;压缩列表（ziplist）是Redis为了节约内存开发的，由一系列特殊编码的连续内存块组成的顺序型数据结构&lt;/p&gt;
&lt;p&gt;一个压缩列表可以包含任意多个节点（entry），每个节点可以保存一个字节数组或一个整数值&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://cdn.jsdelivr.net/gh/davyxx3/pics/blog_img/image-20211206181428515.png&#34; &gt;
		&lt;img src=&#34;https://cdn.jsdelivr.net/gh/davyxx3/pics/blog_img/image-20211206181428515.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;压缩列表的底层结构(1)&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;压缩列表的底层结构(1)&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg-blog.csdnimg.cn%2F20210412174606967.png%3Fx-oss-process%3Dimage%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RRMjAxNjA0MTI%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70&amp;amp;refer=http%3A%2F%2Fimg-blog.csdnimg.cn&amp;amp;app=2002&amp;amp;size=f9999,10000&amp;amp;q=a80&amp;amp;n=0&amp;amp;g=0n&amp;amp;fmt=jpeg?sec=1641233363&amp;amp;t=837f9c66915fca862c652a36f811fc67&#34; &gt;
		&lt;img src=&#34;https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg-blog.csdnimg.cn%2F20210412174606967.png%3Fx-oss-process%3Dimage%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RRMjAxNjA0MTI%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70&amp;amp;refer=http%3A%2F%2Fimg-blog.csdnimg.cn&amp;amp;app=2002&amp;amp;size=f9999,10000&amp;amp;q=a80&amp;amp;n=0&amp;amp;g=0n&amp;amp;fmt=jpeg?sec=1641233363&amp;amp;t=837f9c66915fca862c652a36f811fc67&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;压缩列表的底层结构(2)&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;压缩列表的底层结构(2)&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&#34;压缩列表节点&#34;&gt;压缩列表节点&lt;/h4&gt;
&lt;p&gt;每个压缩列表可以保存一个字节数组或一个整数值&lt;/p&gt;
&lt;p&gt;字节数组是以下三种长度的其中一种：&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://cdn.jsdelivr.net/gh/davyxx3/pics/blog_img/image-20211206181455718.png&#34; &gt;
		&lt;img src=&#34;https://cdn.jsdelivr.net/gh/davyxx3/pics/blog_img/image-20211206181455718.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;字节数组的长度限定&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;字节数组的长度限定&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;整数值是以下六种长度的其中一种：&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://cdn.jsdelivr.net/gh/davyxx3/pics/blog_img/image-20211205022633971.png&#34; &gt;
		&lt;img src=&#34;https://cdn.jsdelivr.net/gh/davyxx3/pics/blog_img/image-20211205022633971.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;整数类型的限定&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;整数类型的限定&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;节点结构：&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://cdn.jsdelivr.net/gh/davyxx3/pics/blog_img/image-20211205022503495.png&#34; &gt;
		&lt;img src=&#34;https://cdn.jsdelivr.net/gh/davyxx3/pics/blog_img/image-20211205022503495.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h5 id=&#34;previous_entry_length&#34;&gt;previous_entry_length&lt;/h5&gt;
&lt;p&gt;长度可以是1字节或5字节，记录了前一个节点的长度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果前一个节点长度小于254字节，则此属性长度为1字节，直接保存长度&lt;/li&gt;
&lt;li&gt;如果前一个节点长度大于等于254字节，则为5字节，第一字节会被设为0xFE，后四个字节保存长度&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以使用此属性从表尾向表头遍历列表&lt;/p&gt;
&lt;h5 id=&#34;encoding&#34;&gt;encoding&lt;/h5&gt;
&lt;p&gt;保存了数据类型和长度，将两部分保存在一起，起到了压缩空间的作用&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://cdn.jsdelivr.net/gh/davyxx3/pics/blog_img/image-20211205023014630.png&#34; &gt;
		&lt;img src=&#34;https://cdn.jsdelivr.net/gh/davyxx3/pics/blog_img/image-20211205023014630.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;编码的规则&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;编码的规则&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h5 id=&#34;content&#34;&gt;content&lt;/h5&gt;
&lt;p&gt;保存节点的值&lt;/p&gt;
&lt;h4 id=&#34;连锁更新&#34;&gt;连锁更新&lt;/h4&gt;
&lt;p&gt;节点的增加或删除，会引起previous_entry_length属性的连锁更新&lt;/p&gt;
&lt;h2 id=&#34;底层对象&#34;&gt;底层对象&lt;/h2&gt;
&lt;p&gt;一种对象可以利用几种数据结构储存对应的数据，需要根据情况来选择&lt;/p&gt;
&lt;p&gt;当在Redis中新建键值对时，我们至少创建了两个对象：键对象和值对象&lt;/p&gt;
&lt;p&gt;每个对象都由一个redisObject结构表示&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://cdn.jsdelivr.net/gh/davyxx3/pics/blog_img/image-20211206181530857.png&#34; &gt;
		&lt;img src=&#34;https://cdn.jsdelivr.net/gh/davyxx3/pics/blog_img/image-20211206181530857.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;对象的底层结构(1)&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;对象的底层结构(1)&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://cdn.jsdelivr.net/gh/davyxx3/pics/blog_img/image-20211206181543696.png&#34; &gt;
		&lt;img src=&#34;https://cdn.jsdelivr.net/gh/davyxx3/pics/blog_img/image-20211206181543696.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;对象的底层结构(2)&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;对象的底层结构(2)&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;类型&#34;&gt;类型&lt;/h3&gt;
&lt;p&gt;五种类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;字符串对象&lt;/li&gt;
&lt;li&gt;列表对象&lt;/li&gt;
&lt;li&gt;哈希对象&lt;/li&gt;
&lt;li&gt;集合对象&lt;/li&gt;
&lt;li&gt;有序集合对象&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于Redis键值对来说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;键：总是一个字符串对象&lt;/li&gt;
&lt;li&gt;值：可以是五种类型中的一种&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以使用TYPE操作查看对象的类型&lt;/p&gt;
&lt;h3 id=&#34;编码&#34;&gt;编码&lt;/h3&gt;
&lt;p&gt;对象实际使用的数据类型由编码决定，也就是redisObject中的encoding属性&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://cdn.jsdelivr.net/gh/davyxx3/pics/blog_img/image-20211206180804399.png&#34; &gt;
		&lt;img src=&#34;https://cdn.jsdelivr.net/gh/davyxx3/pics/blog_img/image-20211206180804399.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;编码常量和数据结构的对应关系&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;编码常量和数据结构的对应关系&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可以使用OBJECT ENCODING操作查看对象的编码&lt;/p&gt;
&lt;p&gt;Redis中对象类型和底层数据结构的关系：&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://cdn.jsdelivr.net/gh/davyxx3/pics/blog_img/image-20211206180812676.png&#34; &gt;
		&lt;img src=&#34;https://cdn.jsdelivr.net/gh/davyxx3/pics/blog_img/image-20211206180812676.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;对象类型和底层数据结构的关系(1)&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;对象类型和底层数据结构的关系(1)&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://cdn.jsdelivr.net/gh/davyxx3/pics/blog_img/image-20211206180821150.png&#34; &gt;
		&lt;img src=&#34;https://cdn.jsdelivr.net/gh/davyxx3/pics/blog_img/image-20211206180821150.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;对象类型和底层数据结构的关系(2)&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;对象类型和底层数据结构的关系(2)&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：有序集合（zset）的跳跃表实现中，同时使用了跳跃表和字典！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;跳跃表按顺序遍历很方便，但查找元素对应的分值不方便，需要O(logN)&lt;/li&gt;
&lt;li&gt;字典查找元素对应的分值方便，为O(1)，但无法做到按顺序遍历&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此有序集合就将它们一起结合使用了，需要查找分值的时候使用字典；需要按顺序遍历或者范围查找的时候使用跳跃表&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://cdn.jsdelivr.net/gh/davyxx3/pics/blog_img/image-20211206180830970.png&#34; &gt;
		&lt;img src=&#34;https://cdn.jsdelivr.net/gh/davyxx3/pics/blog_img/image-20211206180830970.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;Redis底层结构概览&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;Redis底层结构概览&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>AbstractQueuedSynchronizer源码探究</title>
        <link>https://cyderx.com/p/abstractqueuedsynchronizer%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6/</link>
        <pubDate>Tue, 30 Nov 2021 01:00:00 +0800</pubDate>
        
        <guid>https://cyderx.com/p/abstractqueuedsynchronizer%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6/</guid>
        <description>&lt;img src="https://cyderx.com/p/abstractqueuedsynchronizer%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6/bg.jpg" alt="Featured image of post AbstractQueuedSynchronizer源码探究" /&gt;&lt;h2 id=&#34;aqs概念&#34;&gt;AQS概念&lt;/h2&gt;
&lt;p&gt;AbstractQueuedSynchronizer是JUC中非常重要的一个同步控制工具&lt;/p&gt;
&lt;p&gt;在JDK的并发包中，我们能看到很多很多的同步器类，比如ReentrantLock（可重入锁）、Semaphore（信号量）和CountDownLatch（倒计时闭锁）等等&lt;/p&gt;
&lt;p&gt;在这些类中，都使用了AbstractQueuedSynchronizer（AQS）来构建&lt;/p&gt;
&lt;p&gt;它们之间的继承关系如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://cdn.jsdelivr.net/gh/davyxx3/pics/blog_img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20211128020401.jpg&#34; &gt;
		&lt;img src=&#34;https://cdn.jsdelivr.net/gh/davyxx3/pics/blog_img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20211128020401.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;AQS的继承关系&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;AQS的继承关系&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可以看出，在基于AQS构建的同步器类中，都继承了AbstractQueuedSynchronizer的子类，而且名字都叫做Sync&lt;/p&gt;
&lt;p&gt;特别地，在ReentrantLock中Sync有两种实现类：&lt;strong&gt;NonfairSync&lt;/strong&gt;和&lt;strong&gt;FairSync&lt;/strong&gt;，分别实现了对&lt;strong&gt;不公平锁&lt;/strong&gt;和&lt;strong&gt;公平锁&lt;/strong&gt;的控制&lt;/p&gt;
&lt;p&gt;AQS的概念，总共有三点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;状态信息&lt;/strong&gt;：我们需要一个整数来保存当前的同步状态信息，这个信息在AbstractQueuedSynchronizer中由int属性state保存。它可以表示任意状态，比如ReentrantLock用它来表示线程已经重复获取锁的次数，Semaphore用它来表示剩余许可的数量&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;获取&lt;/strong&gt;（aquire）：获取锁或许可，通常会阻塞，直至状态信息处于可被获取的状态&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;释放&lt;/strong&gt;（release）：释放锁或许可，通常不会阻塞，释放操作会唤醒因获取而被阻塞的线程&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;aqs的内部结构&#34;&gt;AQS的内部结构&lt;/h2&gt;
&lt;p&gt;AQS在类内部维护了一个等待队列，这个队列叫作&lt;strong&gt;CLH队列&lt;/strong&gt;。这个CLH队列实际上是一个&lt;strong&gt;双向链表&lt;/strong&gt;，其示意图如下：&lt;figure 
	&gt;
	&lt;a href=&#34;https://cdn.jsdelivr.net/gh/davyxx3/pics/blog_img/20201105015545173.png&#34; &gt;
		&lt;img src=&#34;https://cdn.jsdelivr.net/gh/davyxx3/pics/blog_img/20201105015545173.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;AQS的等待队列（CLH队列）&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;AQS的等待队列（CLH队列）&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;CLH队列的优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先进先出，可以保证公平性&lt;/li&gt;
&lt;li&gt;非阻塞的队列，通过自旋锁和CAS保证节点插入和移除的原子性，实现无锁快速插入&lt;/li&gt;
&lt;li&gt;采用了自旋锁思想，所以CLH队列也是一种基于链表的可扩展、高性能、公平的自旋锁&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;再来看一下AQS的UML图：&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://cdn.jsdelivr.net/gh/davyxx3/pics/blog_img/image-20211128153457909.png&#34; &gt;
		&lt;img src=&#34;https://cdn.jsdelivr.net/gh/davyxx3/pics/blog_img/image-20211128153457909.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;AQS的UML图&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;AQS的UML图&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;我们会发现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;链表的节点就是AQS内部的抽象类Node&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;AQS中的head就是指向队列的head节点，tail指向队列的尾节点&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Node中有指向前节点的指针（prev）和指向后节点的指针（next），用waiter存放与此节点关联的线程，status则指明了线程的状态&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看出，这个等待队列是存放着被阻塞的线程。在这个等待队列中的线程，会不断地尝试acquire，直到获取到锁或许可，改变状态信息为止&lt;/p&gt;
&lt;p&gt;实际上，AQS内部不只是有一个等待队列，它为各个Condition对象都维护了一个&lt;strong&gt;条件等待队列&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;图中的ConditionObject就是一个Condition实现类，内部维护了firstWaiter和lastWaiter，指向队列的头和尾&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://cdn.jsdelivr.net/gh/davyxx3/pics/blog_img/src=http_resource.shangmayuan.com_droxy-blog_2020_01_25_97413281.jpg&#34; &gt;
		&lt;img src=&#34;https://cdn.jsdelivr.net/gh/davyxx3/pics/blog_img/src=http_resource.shangmayuan.com_droxy-blog_2020_01_25_97413281.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;ConditionObject类的结构&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;ConditionObject类的结构&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;当线程因为调用Condition类中的await()挂起时，它们会进入条件等待队列中。当它们被signal()或signalAll()唤醒时，会将他们转移到等待队列中，去尝试acquire&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://cdn.jsdelivr.net/gh/davyxx3/pics/blog_img/1014100-20180627220829936-694191921.png&#34; &gt;
		&lt;img src=&#34;https://cdn.jsdelivr.net/gh/davyxx3/pics/blog_img/1014100-20180627220829936-694191921.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;等待队列（同步队列）和条件等待队列&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;等待队列（同步队列）和条件等待队列&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;因为队列不一样，节点也不一样，因此Node节点派生了3个子类&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SharedNode：共享锁队列的节点&lt;/li&gt;
&lt;li&gt;ExclusiveNode：独占锁队列的节点&lt;/li&gt;
&lt;li&gt;ConditionNode：条件等待队列的节点&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总而言之，AQS的结构如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://cdn.jsdelivr.net/gh/davyxx3/pics/blog_img/image-20211130012721194.png&#34; &gt;
		&lt;img src=&#34;https://cdn.jsdelivr.net/gh/davyxx3/pics/blog_img/image-20211130012721194.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;AQS的总体结构&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;AQS的总体结构&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&#34;源码分析&#34;&gt;源码分析&lt;/h2&gt;
&lt;p&gt;让我们从一个简单的非公平ReentrantLock出发，分析AQS在加锁时的表现&lt;/p&gt;
&lt;h3 id=&#34;lock&#34;&gt;lock()&lt;/h3&gt;
&lt;p&gt;首先调用ReentrantLock的lock()&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 此处是调用了NonFairSync类的lock方法
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// NonFairSync就是AQS在ReentrantLock中的实现类
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;sync&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;进入NonFairSync类的lock方法&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;nd&#34;&gt;@ReservedStackAccess&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(!&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;initialTryLock&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;())&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 首先尝试获取锁，如果没获取到，则进入acquire(1)
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;// 1为要获取的资源数，因为此处为独占锁，所以数量为1
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;acquire&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 调用initialTryLock()尝试获取锁
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 这个方法排除了锁重入的情况，接下来的情况都是非重入情况
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;boolean&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;initialTryLock&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;Thread&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;current&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Thread&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;currentThread&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;compareAndSetState&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 使用CAS设置state，尝试获取锁，如果成功，则设置当前线程为owner
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;setExclusiveOwnerThread&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;current&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;getExclusiveOwnerThread&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;current&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 如果是已经持有锁的线程再次获得锁，则记录重复加锁的数量
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;getState&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 如果重入次数发生溢出，则抛异常
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
            &lt;span class=&#34;k&#34;&gt;throw&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Error&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Maximum lock count exceeded&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;setState&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;进入AbstractQueuedSynchronizer的acquire(int arg)方法&lt;/p&gt;
&lt;p&gt;实际上这个方法是对核心acquire方法的一层简单包装&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;acquire&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;arg&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(!&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tryAcquire&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;arg&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;))&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 再次尝试获取锁，若失败则进入核心的线程同步方法acquire()，在这个方法中实现了对队列的管理
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;acquire&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;arg&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;0L&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 调用tryAcquire方法，再次尝试获取锁
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;protected&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;boolean&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;tryAcquire&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;acquires&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;getState&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;compareAndSetState&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;acquires&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;setExclusiveOwnerThread&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Thread&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;currentThread&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;());&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接下来，我们将进入核心的acquire方法，这是AQS控制线程同步的核心流程，所有使用AQS的工具类最终都会调用此方法&lt;/p&gt;
&lt;p&gt;在分析方法之前，我们先看一下节点有哪些状态（Node的status值）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 节点处于等待状态，值为1（且必须为1）
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;WAITING&lt;/span&gt;   &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 节点被取消调度（被中断或Timeout），这个值必须为负数
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;CANCELLED&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;0x80000000&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 节点处于条件等待队列中
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;COND&lt;/span&gt;      &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;关于acquire方法，官方文档中写道：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;循环做以下几件事情：&lt;/p&gt;
&lt;p&gt;​	检查节点是否为头节点&lt;/p&gt;
&lt;p&gt;​	如果是，则保证head的稳定性，否则保证有效的前节点&lt;/p&gt;
&lt;p&gt;​	如果节点是头节点或仍未入队，则尝试获取&lt;/p&gt;
&lt;p&gt;​	如果节点还未创建，则创建节点&lt;/p&gt;
&lt;p&gt;​	如果节点未入队，则尝试入队一次&lt;/p&gt;
&lt;p&gt;​	如果线程从阻塞中被唤醒， 则再次尝试获取（直至指定的自旋时间）&lt;/p&gt;
&lt;p&gt;​	如果WAITING状态未设置，则设置并重试&lt;/p&gt;
&lt;p&gt;​	否则，阻塞当前线程，清除WAITING状态并检查是否有异常情况&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们可以对照官方文档，理清acquire方法的逻辑&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;acquire&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Node&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;arg&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;boolean&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;shared&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;
                  &lt;span class=&#34;kt&#34;&gt;boolean&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;interruptible&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;boolean&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;timed&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;Thread&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;current&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Thread&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;currentThread&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 自旋的时间
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;byte&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;spins&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;postSpins&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 中断标记，头节点标记
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;boolean&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;interrupted&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;first&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 在入队时的前一个节点
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;Node&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pred&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;// 死循环，不断尝试获取锁
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(;;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(!&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;first&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pred&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;node&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;?&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;prev&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
            &lt;span class=&#34;o&#34;&gt;!(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;first&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;head&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pred&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)))&lt;/span&gt; 
        	&lt;span class=&#34;c1&#34;&gt;// 节点在队列中，且不是头节点时
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pred&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;status&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;c1&#34;&gt;// 如果前一个节点被取消调度，则调用cleanQueue()方法
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                &lt;span class=&#34;c1&#34;&gt;// 此方法的作用是反复遍历CLH队列，清除被取消调度的节点，并唤醒正处于等待的节点
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                &lt;span class=&#34;n&#34;&gt;cleanQueue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
                &lt;span class=&#34;k&#34;&gt;continue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
              &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pred&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;prev&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;c1&#34;&gt;// 此处的代码笔者暂时也不是很清楚，似乎是节点突然间变成了头节点
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                &lt;span class=&#34;c1&#34;&gt;// 所以调用onSpinWait()让出CPU使用权，使得头节点稳定下来（不了解）
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                &lt;span class=&#34;n&#34;&gt;Thread&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;onSpinWait&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
                &lt;span class=&#34;k&#34;&gt;continue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
            &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;first&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pred&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;// 如果节点是头节点，或者还没入队，则尝试获取锁
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;c1&#34;&gt;// 注意，获取锁的顺序并不是严格按照队列的FIFO顺序，未入队的线程也可以尝试获取锁
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;c1&#34;&gt;// 此处就体现了非公平的理念
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;kt&#34;&gt;boolean&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;acquired&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
            &lt;span class=&#34;k&#34;&gt;try&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;shared&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
                    &lt;span class=&#34;n&#34;&gt;acquired&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tryAcquireShared&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;arg&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
                &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;
                    &lt;span class=&#34;n&#34;&gt;acquired&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tryAcquire&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;arg&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
            &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;catch&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Throwable&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ex&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;n&#34;&gt;cancelAcquire&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;interrupted&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
                &lt;span class=&#34;k&#34;&gt;throw&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ex&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
            &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
            &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;acquired&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;first&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
                    &lt;span class=&#34;c1&#34;&gt;// 如果是头节点获取到锁，则此节点成为新的head
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                    &lt;span class=&#34;n&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;prev&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
                    &lt;span class=&#34;n&#34;&gt;head&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
                    &lt;span class=&#34;n&#34;&gt;pred&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;next&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
                    &lt;span class=&#34;n&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;waiter&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
                    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;shared&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
                        &lt;span class=&#34;n&#34;&gt;signalNextIfShared&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
                    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;interrupted&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
                        &lt;span class=&#34;n&#34;&gt;current&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;interrupt&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
                &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
                &lt;span class=&#34;c1&#34;&gt;// 如果成功获取到锁，则返回1，所有获取到锁的线程都会从这里return回去
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
            &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;node&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;// 如果节点仍未创建，则创建节点
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;shared&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
                &lt;span class=&#34;n&#34;&gt;node&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SharedNode&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
            &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;
                &lt;span class=&#34;n&#34;&gt;node&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ExclusiveNode&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pred&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;// 如果节点未入队，则尝试入队
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;n&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;waiter&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;current&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;Node&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tail&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;// 将前一个节点和当前节点联系起来
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;n&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;setPrevRelaxed&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
            &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
                &lt;span class=&#34;c1&#34;&gt;// 如果队列都没创建，则需要创建队列，初始化head
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                &lt;span class=&#34;n&#34;&gt;tryInitializeHead&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
            &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(!&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;casTail&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;))&lt;/span&gt;
                &lt;span class=&#34;c1&#34;&gt;// 利用CAS操作更新tail为当前节点
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                &lt;span class=&#34;c1&#34;&gt;// 如果更新失败，则将当前节点的prev更新成null，在下一次循环中重新进行此操作
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                &lt;span class=&#34;n&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;setPrevRelaxed&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// back out
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;
                &lt;span class=&#34;c1&#34;&gt;// 更新成功，把原tail的next设置为当前节点
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                &lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;next&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;first&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;spins&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;c1&#34;&gt;// 线程被唤醒之后，在自旋时间内持续尝试获取锁
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;spins&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;// 让出CPU使用权
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;n&#34;&gt;Thread&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;onSpinWait&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;status&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;// 如果节点状态未设置，则设置status为WAITING（1）
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;n&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;status&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;WAITING&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nanos&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;// 设置自旋时间
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;n&#34;&gt;spins&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;postSpins&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;byte&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)((&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;postSpins&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
            &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(!&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;timed&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
                &lt;span class=&#34;c1&#34;&gt;// 如果没有设置阻塞时间，则阻塞该线程
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                &lt;span class=&#34;n&#34;&gt;LockSupport&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;park&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
            &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;nanos&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;time&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;nanoTime&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;())&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;0L&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
                &lt;span class=&#34;c1&#34;&gt;// 如果设置了阻塞时间则阻塞指定时间
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                &lt;span class=&#34;n&#34;&gt;LockSupport&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;parkNanos&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nanos&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
            &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;
                &lt;span class=&#34;k&#34;&gt;break&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;// 清除状态
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;n&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;clearStatus&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;// 如果有中断到来，则直接跳出循环
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;interrupted&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Thread&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;interrupted&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;())&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;interruptible&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
                &lt;span class=&#34;k&#34;&gt;break&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 跳出循环说明等待被中断了
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cancelAcquire&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;interrupted&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;interruptible&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;阅读完源码我们可以发现，&lt;strong&gt;所有被锁阻塞的线程，都是阻塞在了这个核心的acquire方法中&lt;/strong&gt;，不断地进行着一个死循环，当获得锁（即CAS改变AQS中的state）时，才能从acquire方法返回，进入到临界区中&lt;/p&gt;
&lt;p&gt;当然，笔者只是给出了一个阅读源码的思路，其中的很多细节，笔者也没有完全搞懂，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调用onSpinWait()的意义何在？&lt;/li&gt;
&lt;li&gt;byte类型的spins和postSpins变量，究竟有什么作用？&lt;/li&gt;
&lt;li&gt;官方文档中的head的稳定性（ensure head stable），真正的含义是什么？&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Doug Lea的代码精妙至极，奈何笔者才疏学浅，疑惑之处甚多，还望各位朋友指点一二&lt;/p&gt;
&lt;h3 id=&#34;unlock&#34;&gt;unlock()&lt;/h3&gt;
&lt;p&gt;看完了加锁的源码，释放锁的源码就比较简单了，很轻松就能看懂&lt;/p&gt;
&lt;p&gt;首先进入ReentrantLock的unlock方法&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;unlock&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;// 将AQS的资源释放
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;sync&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;release&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接着进入AbstractQueuedSynchronizer的release方法，以释放资源&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;boolean&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;release&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;arg&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tryRelease&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;arg&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;c1&#34;&gt;// 释放资源后，还需唤醒下一个节点
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;n&#34;&gt;signalNext&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;head&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 尝试释放锁
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nd&#34;&gt;@ReservedStackAccess&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;protected&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;boolean&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;tryRelease&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;releases&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 现获取的资源数-要释放的资源数
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;getState&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;releases&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 若释放锁的线程和持有锁的线程不一样，则抛出异常
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;getExclusiveOwnerThread&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Thread&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;currentThread&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;())&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;throw&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;IllegalMonitorStateException&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;boolean&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;free&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;free&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// free表示资源没有被线程占用
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;setExclusiveOwnerThread&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;setState&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;free&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最后，调用signalNext方法唤醒下一个线程&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;signalNext&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Node&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;Node&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;h&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;next&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;status&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;c1&#34;&gt;// 取消下一个节点的WAITING状态
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getAndUnsetStatus&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;WAITING&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
      &lt;span class=&#34;c1&#34;&gt;// 唤醒下一个节点
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;n&#34;&gt;LockSupport&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;unpark&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;waiter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;AQS作为一个线程同步工具，其核心特点为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;维护一个状态量，线程可以获取与释放此状态量，来达到获取锁和释放锁的目的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;维护一个等待队列（CLH队列），所有未获取到状态量的线程在其中排队，不断地尝试获取状态量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于每一个条件对象（Condition Object），也维护一个条件等待队列，条件达成后，节点将进入正常的等待队列&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;获取锁后，节点被移出队列；释放锁后，节点会唤醒下一个节点&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>谈谈缓存穿透、击穿和雪崩</title>
        <link>https://cyderx.com/p/%E8%B0%88%E8%B0%88%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%87%BB%E7%A9%BF%E5%92%8C%E9%9B%AA%E5%B4%A9/</link>
        <pubDate>Fri, 26 Nov 2021 10:00:00 +0800</pubDate>
        
        <guid>https://cyderx.com/p/%E8%B0%88%E8%B0%88%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%87%BB%E7%A9%BF%E5%92%8C%E9%9B%AA%E5%B4%A9/</guid>
        <description>&lt;img src="https://cyderx.com/p/%E8%B0%88%E8%B0%88%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%87%BB%E7%A9%BF%E5%92%8C%E9%9B%AA%E5%B4%A9/bg.jpeg" alt="Featured image of post 谈谈缓存穿透、击穿和雪崩" /&gt;&lt;h2 id=&#34;缓存概览&#34;&gt;缓存概览&lt;/h2&gt;
&lt;p&gt;缓存的收益：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;加速读写，优化用户体验&lt;/li&gt;
&lt;li&gt;降低后端负载&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缓存的成本：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据可能无法保证一致性&lt;/li&gt;
&lt;li&gt;架构复杂度增大&lt;/li&gt;
&lt;li&gt;代码维护成本（运维成本）增大&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;适用场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开销大的复杂计算&lt;/li&gt;
&lt;li&gt;加速请求响应&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;缓存穿透及优化&#34;&gt;缓存穿透及优化&lt;/h2&gt;
&lt;p&gt;缓存穿透：查询一个根本不存在的数据，缓存层和存储层都不会命中&lt;/p&gt;
&lt;p&gt;缓存穿透导致不存在的数据每次请求都要到存储层查询，缓存的保护失去了意义，会使后端存储负载加大&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://cdn.jsdelivr.net/gh/davyxx3/pics/blog_imgblog_img1595576768482200.png&#34; &gt;
		&lt;img src=&#34;https://cdn.jsdelivr.net/gh/davyxx3/pics/blog_imgblog_img1595576768482200.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;缓存穿透图示&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;缓存穿透图示&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;解决办法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;缓存空对象：存储层不命中后，将空对象保存至缓存层中，之后的访问都会从缓存层获取，这样就保护了后端数据&lt;/p&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;缓存空对象，意味着缓存中存了更多的键，会占用空间，可以通过设置过期时间解决&lt;/li&gt;
&lt;li&gt;缓存层和存储层会有一段时间窗口的不一致（比如缓存层中存了空对象并设置过期时间为5分钟，但此时存储层刚好添加了该键对应的数据，就造成了数据不一致），可以使用消息系统或者其他方式解决&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;布隆过滤器拦截：缓存穿透是查询一个根本不存在的数据，因此可以在缓存层前加一个布隆过滤器，将不存在的数据拦截。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;关于布隆过滤器，可以查看我写的另一篇文章：&lt;a class=&#34;link&#34; href=&#34;https://davyxx3.github.io/p/%e5%b8%83%e9%9a%86%e8%bf%87%e6%bb%a4%e5%99%a8%e7%9a%84%e7%ae%80%e5%8d%95%e6%80%bb%e7%bb%93/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;布隆过滤器的简单总结&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://cdn.jsdelivr.net/gh/davyxx3/pics/blog_imgblog_imgC5EA64EDF8B5D89FE14B8A19730D6CA6.jpg&#34; &gt;
		&lt;img src=&#34;https://cdn.jsdelivr.net/gh/davyxx3/pics/blog_imgblog_imgC5EA64EDF8B5D89FE14B8A19730D6CA6.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;两种解决方式的对比&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;解决方式&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;适用场景&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;代价&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;缓存空对象&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;数据命中不高、数据变化频繁（实时性高）&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;需要过多缓存空间、数据不一致&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;布隆过滤器&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;数据命中不高，数据相对固定（实时性低）&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;代码维护复杂&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;PS：布隆过滤器不适用于数据变化频繁的场景（因为要不停地进行数据的插入和删除，而布隆过滤器对于删除操作极不友好），比较适用于数据相对固定的场景&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;缓存击穿及优化&#34;&gt;缓存击穿及优化&lt;/h2&gt;
&lt;p&gt;缓存层的某个key承受着非常高的并发，当这个key失效的瞬间，大量的请求会同时击穿缓存，打到DB，就像在纱窗上戳破了一个洞&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://cdn.jsdelivr.net/gh/davyxx3/pics/blog_img/20211127222433.png&#34; &gt;
		&lt;img src=&#34;https://cdn.jsdelivr.net/gh/davyxx3/pics/blog_img/20211127222433.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;缓存击穿图示&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;缓存击穿图示&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;解决方法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;设置热点数据不过期，这里的不过期是指物理上的不过期。我们可以设置一个逻辑过期时间，当超过逻辑过期时间时，异步地加载数据，更新缓存。这种方法适用于比较极端的场景（流量特别大），需要承受数据不一致的代价（缓存重构需要时间）&lt;/li&gt;
&lt;li&gt;给访问DB操作加上互斥锁，只有一个线程能拿到锁，请求DB并把数据刷到缓存中，其他线程再从缓存拿这个数据&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;两种解决方法的对比&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;解决方法&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;优点&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;缺点&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;简单分布式锁&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;思路简单、保证一致性&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;代码复杂度大、存在死锁和线程池阻塞的风险&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;热点数据永不过期&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;杜绝缓存击穿问题&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;不保证一致性、代码维护成本和内存成本增加&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;缓存雪崩及优化&#34;&gt;缓存雪崩及优化&lt;/h2&gt;
&lt;p&gt;缓存层因为某些原因无法提供服务（比如缓存服务器重启，或者大量key在同一时间失效等情况），所有请求都打到存储层，则存储层的调用量会暴增，造成存储层也级联宕机的情况&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://cdn.jsdelivr.net/gh/davyxx3/pics/blog_imgblog_img965d07c7bd3192445850c1ed1bc2c9f0.png&#34; &gt;
		&lt;img src=&#34;https://cdn.jsdelivr.net/gh/davyxx3/pics/blog_imgblog_img965d07c7bd3192445850c1ed1bc2c9f0.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;针对两种情况，有不同的解决方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;缓存层宕机的解决方法：
&lt;ol&gt;
&lt;li&gt;保证缓存层服务高可用，例如使用Redis Sentinel或者Redis Cluster&lt;/li&gt;
&lt;li&gt;使用隔离组件为后端限流并降级：限制存储层的访问流量（服务限流），并主动停掉一些不太重要的业务，减轻存储层的压力（服务降级）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;大量key在同一时间失效的解决方法：
&lt;ol&gt;
&lt;li&gt;在原有的失效时间基础上增加一个随机值，防止大批key在同一时刻失效&lt;/li&gt;
&lt;li&gt;若缓存层是分布式存储，可以将热点数据均匀分布在不同的库中&lt;/li&gt;
&lt;li&gt;设置热点数据永不过期（如上文所说，需要承受数据不一致的代价）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>布隆过滤器的简单总结</title>
        <link>https://cyderx.com/p/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/</link>
        <pubDate>Fri, 26 Nov 2021 08:00:00 +0800</pubDate>
        
        <guid>https://cyderx.com/p/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/</guid>
        <description>&lt;img src="https://cyderx.com/p/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/bg.jpeg" alt="Featured image of post 布隆过滤器的简单总结" /&gt;&lt;p&gt;布隆过滤器（Bloom Filter）是一个很长的二进制向量和一系列随机映射函数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用途：判断一个元素是否在一个集合中&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;严谨来说，应该是：判断某样东西一定不存在或可能存在&lt;/p&gt;
&lt;h2 id=&#34;数据存入&#34;&gt;数据存入&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;经过K个哈希函数计算，返回K个计算出的hash值&lt;/li&gt;
&lt;li&gt;这k个hash值映射到对应的k个数组下标&lt;/li&gt;
&lt;li&gt;将二进制向量中这k个下标的对应数据改为1&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://cdn.jsdelivr.net/gh/davyxx3/pics/blog_img/74275c10493948b7b27babe87b226efc-1.jpg&#34; &gt;
		&lt;img src=&#34;https://cdn.jsdelivr.net/gh/davyxx3/pics/blog_img/74275c10493948b7b27babe87b226efc-1.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;数据存入的过程&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;数据存入的过程&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&#34;数据查询&#34;&gt;数据查询&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;经过K个哈希函数计算该数据，算出k个hash值&lt;/li&gt;
&lt;li&gt;以hash值为下标在二进制向量中找到对应的数据&lt;/li&gt;
&lt;li&gt;若有一处的数据为0，则该数据不存在，否则说明数据&lt;strong&gt;可能&lt;/strong&gt;存在（并不是一定存在，有误判的可能）&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;参数选择&#34;&gt;参数选择&lt;/h2&gt;
&lt;p&gt;二进制向量的长度会影响误报率，长度越长，误报率越低&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若长度太小，所有bit都置成1的话，那么查询任何值都会返回“可能存在”，无法起到过滤的目的&lt;/li&gt;
&lt;li&gt;若长度太大，则可能会造成空间浪费&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;哈希函数的个数也会影响误报率，函数个数越多，误报率越低&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若函数个数太多，则二进制向量置1的速度会变得很快，这样布隆过滤器的效率会变低&lt;/li&gt;
&lt;li&gt;若函数个数太少，则误报率变高&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参数的选取公式：&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://cdn.jsdelivr.net/gh/davyxx3/pics/blog_img/v2-1ed5b79aa7ac2e9cd66c83690fdbfcf0_720w.jpg&#34; &gt;
		&lt;img src=&#34;https://cdn.jsdelivr.net/gh/davyxx3/pics/blog_img/v2-1ed5b79aa7ac2e9cd66c83690fdbfcf0_720w.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;m和k的计算公式&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;m和k的计算公式&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;k为哈希函数个数，m为布隆过滤器长度，n为插入元素的个数，p为误报率&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;占用空间小（存储的是二进制数据）&lt;/li&gt;
&lt;li&gt;查询速度快，时间复杂度为O(k)&lt;/li&gt;
&lt;li&gt;保密性很好，不存储任何原始数据，只有二进制数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;存在误判的可能（不同的数据可能映射到二进制向量中的相同位置）&lt;/li&gt;
&lt;li&gt;删除困难，也是因为上述的理由&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;与HashMap的比较：&lt;/p&gt;
&lt;p&gt;HashMap速度也很快，但占用空间太大，因为有负载因子的存在，为了避免哈希冲突，空间是没办法用满的，会造成大量的空间浪费。使用布隆过滤器可以在不牺牲查找速度的同时，降低空间消耗，代价就是判断并不完全准确&lt;/p&gt;
&lt;p&gt;应用场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;URL黑名单过滤&lt;/li&gt;
&lt;li&gt;解决缓存穿透的问题&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>ConcurrentLinkedQueue源码分析</title>
        <link>https://cyderx.com/p/concurrentlinkedqueue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link>
        <pubDate>Fri, 26 Nov 2021 01:00:00 +0800</pubDate>
        
        <guid>https://cyderx.com/p/concurrentlinkedqueue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid>
        <description>&lt;img src="https://cyderx.com/p/concurrentlinkedqueue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/CLQ.jpg" alt="Featured image of post ConcurrentLinkedQueue源码分析" /&gt;&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;ConcurrentLinkedQueue是高并发环境中性能最好的队列&lt;/p&gt;
&lt;p&gt;要想队列保证线程安全，有两种实现方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;阻塞算法：锁&lt;/li&gt;
&lt;li&gt;非阻塞算法：循环CAS&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在队列中，BlockingQueue是阻塞算法的典型实现（使用锁来保证线程安全），而ConcurrentLinkedQueue则是非阻塞算法的典型实现（使用CAS保证线程安全）&lt;/p&gt;
&lt;h2 id=&#34;原理&#34;&gt;原理&lt;/h2&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://cdn.jsdelivr.net/gh/davyxx3/pics/blog_img807144-3d3261a627e586dc.jpg&#34; &gt;
		&lt;img src=&#34;https://cdn.jsdelivr.net/gh/davyxx3/pics/blog_img807144-3d3261a627e586dc.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;ConcurrentLinkedQueue的基本结构&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;ConcurrentLinkedQueue的基本结构&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Node节点&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Node&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;E&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;volatile&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;E&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;item&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;volatile&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Node&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;E&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;next&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;// 利用CAS操作向后添加一个节点
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;appendRelaxed&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Node&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;E&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;next&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;NEXT&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;set&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;next&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;// 利用CAS操作设置值（cmp是期望值，val是要设置的值）
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;boolean&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;casItem&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;E&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cmp&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;E&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;val&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ITEM&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;compareAndSet&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cmp&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;val&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;head和tail&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kd&#34;&gt;transient&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;volatile&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Node&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;E&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;head&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;transient&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;volatile&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Node&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;E&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tail&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 初始时，head和tail都指向一个空节点
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;ConcurrentLinkedQueue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;head&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tail&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Node&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;E&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;();&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;CoucurrentLinkedQueue规定了如下几个不变性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;最后一个元素的next为null&lt;/li&gt;
&lt;li&gt;队列中所有未删除的节点的item都不能为null，且都能从head节点遍历到&lt;/li&gt;
&lt;li&gt;对于要删除的节点，不是直接将其设置为null，而是先将其item域设置为null（迭代器会跳过item为null的节点）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;head和tail并不一定指向真正的头和尾节点，因为它们的更新有滞后性，每次更新会跳跃两个元素&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;入队&#34;&gt;入队&lt;/h3&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://cdn.jsdelivr.net/gh/davyxx3/pics/blog_imgb04f6051-c6fa-4050-be13-6407b6c4c9f1.png&#34; &gt;
		&lt;img src=&#34;https://cdn.jsdelivr.net/gh/davyxx3/pics/blog_imgb04f6051-c6fa-4050-be13-6407b6c4c9f1.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;入队过程&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;入队过程&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;boolean&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;offer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;E&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 确保值不为空，且创建新节点
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Node&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;E&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;newNode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Node&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;E&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Objects&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;requireNonNull&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;));&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;// 循环进行CAS操作，直至成功为止（因为CAS操作有可能失败）
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// t：指向tail
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// p、q：进行遍历使用的指针，p在前，q在后
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Node&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;E&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tail&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;Node&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;E&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;q&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;next&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;q&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;// p是最后一个节点的情况，此时q为null
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;NEXT&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;compareAndSet&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;newNode&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;c1&#34;&gt;// 将新创建的节点添加到链表末尾
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
                &lt;span class=&#34;c1&#34;&gt;// 当p和t不相等，也就是新创建的节点和原tail中间隔着一个元素时，才更新tail，相当于tail的1次更新跨越2个元素
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                    &lt;span class=&#34;n&#34;&gt;TAIL&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;weakCompareAndSet&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;newNode&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
                &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
            &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;// CAS失败，再次尝试
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;q&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;// 遇到了哨兵节点，从head开始重新遍历，或者如果有其他线程修改了tail，就使用这个刚被修改的tail
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;c1&#34;&gt;// t != (t = tail)是为了检查在执行过程中，tail是否被其他线程修改，如果是，则进行一次“打赌”，将刚被修改的tail当作链表末尾
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;c1&#34;&gt;// 这样就可以提高性能，省去了重新查找tail的开销
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tail&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;?&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;head&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;// p不是最后一个节点的情况（添加了节点，tail未更新的情况）
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;c1&#34;&gt;// 将p不断推进到链表末尾
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tail&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;?&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;q&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;在JDK 1.7的实现中，doug lea使用hops变量来控制并减少tail节点的更新频率，并不是每次节点入队后都将 tail节点更新成尾节点，而是当tail节点和尾节点的距离大于等于常量HOPS的值（默认等于1）时才更新tail节点，tail和尾节点的距离越长使用CAS更新tail节点的次数就会越少，但是距离越长带来的负面效果就是每次入队时定位尾节点的时间就越长，因为循环体需要多循环一次来定位出尾节点，但是这样仍然能提高入队的效率，因为从本质上来看它通过增加对volatile变量的读操作来减少了对volatile变量的写操作，而对volatile变量的写操作开销要远远大于读操作，所以入队效率会有所提升。&lt;/p&gt;
&lt;p&gt;在JDK 1.8的实现中，tail的更新时机是通过p和t是否相等来判断的，其实现结果和JDK 1.7相同，即当tail节点和尾节点的距离大于等于1时，更新tail。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;出队&#34;&gt;出队&lt;/h3&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://cdn.jsdelivr.net/gh/davyxx3/pics/blog_img20180625144156632&#34; &gt;
		&lt;img src=&#34;https://cdn.jsdelivr.net/gh/davyxx3/pics/blog_img20180625144156632&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;出队过程&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;出队过程&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;E&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;poll&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 循环进行CAS操作
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;restartFromHead&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(;;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Node&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;E&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;h&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;head&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;q&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;q&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;E&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;item&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
            &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;item&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;item&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;casItem&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;item&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;c1&#34;&gt;// p的item值不为null，说明是有效节点，并使用CAS将p的item置为null
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
                    &lt;span class=&#34;c1&#34;&gt;// head的1次更新会跨越2个元素（当head指向的节点中元素为null，才更新head）
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                    &lt;span class=&#34;c1&#34;&gt;// 更新head的同时，原先的head成为哨兵节点（next指向自己的节点）
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                    &lt;span class=&#34;n&#34;&gt;updateHead&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;q&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;next&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;?&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;q&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
                &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;item&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
            &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
            &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;q&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;next&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;c1&#34;&gt;// 链表为空，则更新head，并返回null
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                &lt;span class=&#34;n&#34;&gt;updateHead&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
                &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
            &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
            &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;q&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
                &lt;span class=&#34;c1&#34;&gt;// 遇到哨兵节点，重新从head开始遍历
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                &lt;span class=&#34;k&#34;&gt;continue&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;restartFromHead&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;使用CAS原子指令处理对数据的并发访问&lt;/li&gt;
&lt;li&gt;head和tail并非总是指向队列的头和尾节点，也就是说允许队列处于不一致状态。这个特性把入队、出队时，原本需要一起原子化执行的两个步骤分离开来，缩小了入队、出队时需要原子化更新值的范围到唯一变量，而head和tail的更新使用批处理的方式完成（一次更新2步）。这样的做法减少了入队、出队操作的开销，提高了入队、出队的性能&lt;/li&gt;
&lt;li&gt;因为队列有时会处于不一致状态，所以ConcurrentLinkedQueue 使用三个不变式来维护非阻塞算法的正确性&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
    </channel>
</rss>
